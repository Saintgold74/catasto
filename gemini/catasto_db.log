2025-04-28 10:05:53,983 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 10:05:54,252 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 10:07:52,448 - CatastoDB - INFO - Disconnessione completata
2025-04-28 10:43:17,014 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 10:43:17,157 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 10:47:33,588 - CatastoDB - ERROR - Errore DB specifico rilevato: DatatypeMismatch - ERRORE:  structure of query does not match function result type
DETAIL:  Il tipo restituito real non corrisponde al tipo attesto double precision nella colonna 4.
CONTEXT:  istruzione SQL "SELECT 
        p.id,
        p.nome_completo,
        p.comune_nome,
        GREATEST(
            similarity(p.nome_completo, p_query),
            similarity(p.cognome_nome, p_query),
            similarity(p.paternita, p_query)
        ) AS similarity,
        COUNT(DISTINCT pp.partita_id) AS num_partite
    FROM possessore p
    LEFT JOIN partita_possessore pp ON p.id = pp.possessore_id
    WHERE 
        p.nome_completo ILIKE '%' || p_query || '%' OR
        p.cognome_nome ILIKE '%' || p_query || '%' OR
        p.paternita ILIKE '%' || p_query || '%'
    GROUP BY p.id, p.nome_completo, p.comune_nome
    ORDER BY similarity DESC, num_partite DESC"
funzione PL/pgSQL ricerca_avanzata_possessori(text) riga 3 a RETURN QUERY

2025-04-28 10:47:33,589 - CatastoDB - ERROR - Query: b"SELECT * FROM ricerca_avanzata_possessori('cognome')"
2025-04-28 10:47:33,590 - CatastoDB - ERROR - Parametri: ('cognome',)
2025-04-28 10:47:33,591 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 10:47:33,591 - CatastoDB - ERROR - Errore ricerca avanzata possessori: ERRORE:  structure of query does not match function result type
DETAIL:  Il tipo restituito real non corrisponde al tipo attesto double precision nella colonna 4.
CONTEXT:  istruzione SQL "SELECT 
        p.id,
        p.nome_completo,
        p.comune_nome,
        GREATEST(
            similarity(p.nome_completo, p_query),
            similarity(p.cognome_nome, p_query),
            similarity(p.paternita, p_query)
        ) AS similarity,
        COUNT(DISTINCT pp.partita_id) AS num_partite
    FROM possessore p
    LEFT JOIN partita_possessore pp ON p.id = pp.possessore_id
    WHERE 
        p.nome_completo ILIKE '%' || p_query || '%' OR
        p.cognome_nome ILIKE '%' || p_query || '%' OR
        p.paternita ILIKE '%' || p_query || '%'
    GROUP BY p.id, p.nome_completo, p.comune_nome
    ORDER BY similarity DESC, num_partite DESC"
funzione PL/pgSQL ricerca_avanzata_possessori(text) riga 3 a RETURN QUERY

2025-04-28 11:07:47,391 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  il record "new" non ha un campo "id"
CONTEXT:  Assegnazione PL/pgSQL "v_record_id := NEW.id"
funzione PL/pgSQL audit_trigger_function() riga 23 a assegnazione

2025-04-28 11:07:47,392 - CatastoDB - ERROR - Query: b"INSERT INTO comune (nome, provincia, regione, periodo_id) VALUES ('Albissola Mare', 'Savona', 'Liguria', 1) ON CONFLICT (nome) DO NOTHING"
2025-04-28 11:07:47,392 - CatastoDB - ERROR - Parametri: ('Albissola Mare', 'Savona', 'Liguria', 1)
2025-04-28 11:07:47,393 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:07:47,395 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:08:28,544 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:08:28,613 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:09:24,269 - CatastoDB - ERROR - Errore DB specifico rilevato: ForeignKeyViolation - ERRORE:  la INSERT o l'UPDATE sulla tabella "possessore" viola il vincolo di chiave esterna "possessore_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".
CONTEXT:  istruzione SQL "INSERT INTO possessore(comune_nome, cognome_nome, paternita, nome_completo, attivo)
    VALUES (p_comune_nome, p_cognome_nome, p_paternita, p_nome_completo, p_attivo)"
funzione PL/pgSQL inserisci_possessore(character varying,character varying,character varying,character varying,boolean) riga 3 a istruzione SQL

2025-04-28 11:09:24,270 - CatastoDB - ERROR - Query: b"CALL inserisci_possessore('Cairo', 'Cippalippa Asdrubale', 'di Gennaro', 'Cippalippa Asdrubale di Gennaro', true)"
2025-04-28 11:09:24,270 - CatastoDB - ERROR - Parametri: ('Cairo', 'Cippalippa Asdrubale', 'di Gennaro', 'Cippalippa Asdrubale di Gennaro', True)
2025-04-28 11:09:24,271 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:09:24,271 - CatastoDB - ERROR - Errore DB specifico in insert_possessore: ERRORE:  la INSERT o l'UPDATE sulla tabella "possessore" viola il vincolo di chiave esterna "possessore_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".
CONTEXT:  istruzione SQL "INSERT INTO possessore(comune_nome, cognome_nome, paternita, nome_completo, attivo)
    VALUES (p_comune_nome, p_cognome_nome, p_paternita, p_nome_completo, p_attivo)"
funzione PL/pgSQL inserisci_possessore(character varying,character varying,character varying,character varying,boolean) riga 3 a istruzione SQL

2025-04-28 11:11:08,736 - CatastoDB - INFO - Commit eseguito.
2025-04-28 11:14:03,374 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  il record "new" non ha un campo "id"
CONTEXT:  Assegnazione PL/pgSQL "v_record_id := NEW.id"
funzione PL/pgSQL audit_trigger_function() riga 23 a assegnazione

2025-04-28 11:14:03,375 - CatastoDB - ERROR - Query: b"INSERT INTO comune (nome, provincia, regione, periodo_id) VALUES ('Albissola Mare', 'Savona', 'Liguria', 3) ON CONFLICT (nome) DO NOTHING"
2025-04-28 11:14:03,375 - CatastoDB - ERROR - Parametri: ('Albissola Mare', 'Savona', 'Liguria', 3)
2025-04-28 11:14:03,376 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:14:03,378 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:29:29,945 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:29:30,061 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:29:57,808 - CatastoDB - ERROR - Errore DB specifico rilevato: ForeignKeyViolation - ERRORE:  la INSERT o l'UPDATE sulla tabella "localita" viola il vincolo di chiave esterna "localita_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".

2025-04-28 11:29:57,808 - CatastoDB - ERROR - Query: b"INSERT INTO localita (comune_nome, nome, tipo, civico) VALUES ('Cairo', 'Regione Pisqualo', 'regione', NULL) ON CONFLICT (comune_nome, nome, civico) DO NOTHING RETURNING id"
2025-04-28 11:29:57,808 - CatastoDB - ERROR - Parametri: ('Cairo', 'Regione Pisqualo', 'regione', None)
2025-04-28 11:29:57,809 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:29:57,809 - CatastoDB - ERROR - Errore DB in insert_localita: ERRORE:  la INSERT o l'UPDATE sulla tabella "localita" viola il vincolo di chiave esterna "localita_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".

2025-04-28 11:30:33,979 - CatastoDB - INFO - Commit eseguito.
2025-04-28 11:33:09,115 - CatastoDB - ERROR - Errore DB specifico rilevato: ForeignKeyViolation - ERRORE:  la INSERT o l'UPDATE sulla tabella "localita" viola il vincolo di chiave esterna "localita_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".

2025-04-28 11:33:09,115 - CatastoDB - ERROR - Query: b"INSERT INTO localita (comune_nome, nome, tipo, civico) VALUES ('Cairo', 'Regione Pistola', 'via', NULL) ON CONFLICT (comune_nome, nome, civico) DO NOTHING RETURNING id"
2025-04-28 11:33:09,116 - CatastoDB - ERROR - Parametri: ('Cairo', 'Regione Pistola', 'via', None)
2025-04-28 11:33:09,117 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:33:09,117 - CatastoDB - ERROR - Errore DB in insert_localita: ERRORE:  la INSERT o l'UPDATE sulla tabella "localita" viola il vincolo di chiave esterna "localita_comune_nome_fkey"
DETAIL:  La chiave (comune_nome)=(Cairo) non Ë presente nella tabella "comune".

2025-04-28 11:37:31,373 - CatastoDB - ERROR - Errore DB specifico rilevato: CheckViolation - ERRORE:  la nuova riga per la relazione "variazione" viola il vincolo di controllo "variazione_tipo_check"
DETAIL:  La riga in errore contiene (3, 1, 14, Vendita, 2025-01-01, 777, Genny Lo Smilzo, 2025-04-28 11:34:29.921132, 2025-04-28 11:34:29.921132).
CONTEXT:  istruzione SQL "INSERT INTO variazione(
        partita_origine_id, partita_destinazione_id, tipo, 
        data_variazione, numero_riferimento, nominativo_riferimento
    )
    VALUES (
        p_partita_origine_id, v_nuova_partita_id, p_tipo_variazione,
        p_data_variazione, p_numero_partita::TEXT, 
        (SELECT string_agg(nome_completo, ', ') FROM possessore WHERE id = ANY(v_possessore_ids))
    )
    RETURNING id"
funzione PL/pgSQL registra_passaggio_proprieta(integer,character varying,integer,character varying,date,character varying,date,character varying,character varying,json,integer[],text) riga 83 a istruzione SQL

2025-04-28 11:37:31,374 - CatastoDB - ERROR - Query: b'CALL registra_passaggio_proprieta(1, \'Carcare\', 777, \'Vendita\', \'2025-01-01\'::date, \'Vendita\', \'1950-01-01\'::date, \'Sir Giacomo Stopardi\', NULL, \'[{"nome_completo": "Genny Lo Smilzo", "cognome_nome": "Smilzo Genny", "paternita": "di Savastano"}]\', NULL, NULL)'
2025-04-28 11:37:31,374 - CatastoDB - ERROR - Parametri: (1, 'Carcare', 777, 'Vendita', datetime.date(2025, 1, 1), 'Vendita', datetime.date(1950, 1, 1), 'Sir Giacomo Stopardi', None, '[{"nome_completo": "Genny Lo Smilzo", "cognome_nome": "Smilzo Genny", "paternita": "di Savastano"}]', None, None)
2025-04-28 11:37:31,375 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:37:31,375 - CatastoDB - ERROR - Errore DB passaggio prop.: ERRORE:  la nuova riga per la relazione "variazione" viola il vincolo di controllo "variazione_tipo_check"
DETAIL:  La riga in errore contiene (3, 1, 14, Vendita, 2025-01-01, 777, Genny Lo Smilzo, 2025-04-28 11:34:29.921132, 2025-04-28 11:34:29.921132).
CONTEXT:  istruzione SQL "INSERT INTO variazione(
        partita_origine_id, partita_destinazione_id, tipo, 
        data_variazione, numero_riferimento, nominativo_riferimento
    )
    VALUES (
        p_partita_origine_id, v_nuova_partita_id, p_tipo_variazione,
        p_data_variazione, p_numero_partita::TEXT, 
        (SELECT string_agg(nome_completo, ', ') FROM possessore WHERE id = ANY(v_possessore_ids))
    )
    RETURNING id"
funzione PL/pgSQL registra_passaggio_proprieta(integer,character varying,integer,character varying,date,character varying,date,character varying,character varying,json,integer[],text) riga 83 a istruzione SQL

2025-04-28 11:39:28,158 - CatastoDB - INFO - Commit eseguito.
2025-04-28 11:39:28,158 - CatastoDB - INFO - Reg. consultazione: Commissario Scialoia, 2025-04-28
2025-04-28 11:41:31,840 - CatastoDB - ERROR - Errore DB specifico rilevato: RaiseException - ERRORE:  Errore durante l'inserimento del contratto: Esiste gi√† un contratto per la variazione con ID 1
CONTEXT:  funzione PL/pgSQL inserisci_contratto(integer,character varying,date,character varying,character varying,text) riga 24 a RAISE

2025-04-28 11:41:31,841 - CatastoDB - ERROR - Query: b"CALL inserisci_contratto(1, 'Vendita', '2025-01-01'::date, NULL, NULL, NULL)"
2025-04-28 11:41:31,841 - CatastoDB - ERROR - Parametri: (1, 'Vendita', datetime.date(2025, 1, 1), None, None, None)
2025-04-28 11:41:31,842 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 11:41:31,843 - CatastoDB - ERROR - Errore ins contratto var 1: ERRORE:  Errore durante l'inserimento del contratto: Esiste gi√† un contratto per la variazione con ID 1
CONTEXT:  funzione PL/pgSQL inserisci_contratto(integer,character varying,date,character varying,character varying,text) riga 24 a RAISE

2025-04-28 11:42:23,774 - CatastoDB - INFO - Commit eseguito.
2025-04-28 11:47:51,154 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:48:18,201 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:48:18,268 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:48:27,414 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:48:49,322 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:48:49,499 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:48:55,384 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:50:08,224 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:50:08,298 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:50:14,050 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:50:17,404 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:50:17,615 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:50:23,371 - CatastoDB - INFO - Disconnessione completata
2025-04-28 11:50:34,189 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 11:50:34,257 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 11:50:40,544 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:00:24,954 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:00:25,085 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:00:38,777 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_statistiche_comune'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 920, in menu_report
    stats = db.get_statistiche_comune()
            ^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_statistiche_comune'
2025-04-28 12:00:38,827 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:02:03,051 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:02:03,120 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:02:10,981 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 933, in menu_report
    stats = db.get_immobili_per_tipologia(comune_nome=comune_filter)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
2025-04-28 12:02:11,015 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:02:17,621 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:02:17,689 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:05:58,981 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:06:03,655 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:06:03,725 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:08:02,765 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 933, in menu_report
    stats = db.get_immobili_per_tipologia(comune_nome=comune_filter)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
2025-04-28 12:08:02,801 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:08:06,750 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:08:06,818 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:08:13,864 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_partite_complete_view'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 950, in menu_report
    partite = db.get_partite_complete_view(comune_nome=comune_filter, stato=stato_filter)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_partite_complete_view'
2025-04-28 12:08:13,901 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:08:39,276 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:08:39,459 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:11:33,536 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:16:21,771 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:16:21,862 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:17:16,148 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 933, in menu_report
    stats = db.get_immobili_per_tipologia(comune_nome=comune_filter)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_immobili_per_tipologia'
2025-04-28 12:17:16,178 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:18:22,851 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:18:22,921 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:19:39,078 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_report_annuale_partite'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 982, in menu_report
    report = db.get_report_annuale_partite(comune, anno)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_report_annuale_partite'
2025-04-28 12:19:39,115 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:21:44,808 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:21:44,878 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:24:01,305 - __main__ - ERROR - Errore non gestito nel menu principale: 'CatastoDBManager' object has no attribute 'get_report_proprieta_possessore'
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1635, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 237, in menu_principale
    elif scelta == "3": menu_report(db)
                        ~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1004, in menu_report
    report = db.get_report_proprieta_possessore(possessore_id, data_inizio, data_fine)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'CatastoDBManager' object has no attribute 'get_report_proprieta_possessore'
2025-04-28 12:24:01,344 - CatastoDB - INFO - Disconnessione completata
2025-04-28 12:25:03,001 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 12:25:03,073 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 12:30:03,871 - CatastoDB - INFO - Disconnessione completata
2025-04-28 15:38:07,855 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 15:38:07,981 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 15:38:28,535 - CatastoDB - INFO - Avvio manutenzione database...
2025-04-28 15:38:28,555 - CatastoDB - ERROR - Errore DB specifico rilevato: ActiveSqlTransaction - ERRORE:  non Ë possibile eseguire VACUUM all'interno di un blocco di transazione
CONTEXT:  istruzione SQL "VACUUM ANALYZE catasto.registro_partite"
funzione PL/pgSQL manutenzione_database() riga 11 a EXECUTE

2025-04-28 15:38:28,561 - CatastoDB - ERROR - Query: b'CALL manutenzione_database()'
2025-04-28 15:38:28,566 - CatastoDB - ERROR - Parametri: None
2025-04-28 15:38:28,572 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:38:28,577 - CatastoDB - ERROR - Errore DB manutenzione: ERRORE:  non Ë possibile eseguire VACUUM all'interno di un blocco di transazione
CONTEXT:  istruzione SQL "VACUUM ANALYZE catasto.registro_partite"
funzione PL/pgSQL manutenzione_database() riga 11 a EXECUTE

2025-04-28 15:39:42,155 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:39:42,161 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 15:39:42,166 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 15:39:42,172 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:39:42,177 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:40:35,827 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:40:35,834 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 15:40:35,839 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 15:40:35,844 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:40:35,849 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:43:27,146 - CatastoDB - INFO - Disconnessione completata
2025-04-28 15:43:30,475 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 15:43:30,603 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 15:43:52,370 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:43:52,376 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 15:43:52,381 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 15:43:52,390 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:43:52,395 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:44:56,857 - CatastoDB - INFO - Disconnessione completata
2025-04-28 15:46:37,798 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 15:46:37,922 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 15:47:34,733 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:47:34,740 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 15:47:34,745 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 15:47:34,751 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:47:34,756 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:51:58,388 - CatastoDB - INFO - Disconnessione completata
2025-04-28 15:52:52,472 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 15:52:52,596 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 15:53:00,008 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 15:53:00,014 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 15:53:00,023 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 15:53:00,030 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 15:53:00,035 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:00:10,125 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:00:10,132 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 16:00:10,137 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 16:00:10,143 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 16:00:10,148 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:05:42,795 - CatastoDB - INFO - Disconnessione completata
2025-04-28 16:07:01,283 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 16:07:01,406 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 16:07:08,452 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:07:08,459 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 16:07:08,464 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 16:07:08,469 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 16:07:08,474 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:12:19,606 - CatastoDB - INFO - Disconnessione completata
2025-04-28 16:12:22,754 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 16:12:22,879 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 16:12:32,844 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:12:32,851 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Carcare')"
2025-04-28 16:12:32,857 - CatastoDB - ERROR - Parametri: ('Carcare',)
2025-04-28 16:12:32,863 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 16:12:32,869 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Carcare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:13:44,893 - CatastoDB - INFO - Disconnessione completata
2025-04-28 16:14:31,148 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-28 16:14:31,258 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-28 16:14:37,315 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:14:37,321 - CatastoDB - ERROR - Query: b"SELECT * FROM genera_report_comune('Altare')"
2025-04-28 16:14:37,325 - CatastoDB - ERROR - Parametri: ('Altare',)
2025-04-28 16:14:37,330 - CatastoDB - INFO - Rollback eseguito.
2025-04-28 16:14:37,336 - CatastoDB - ERROR - Errore DB in get_report_comune (Comune: Altare): ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 10: ...           SELECT json_object_agg(classificazione, COUNT(*))
                                                               ^
QUERY:  WITH stats AS (
        SELECT
            p.comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive,
            (
                SELECT json_object_agg(classificazione, COUNT(*))
                FROM (
                    SELECT i.classificazione, COUNT(*) 
                    FROM immobile i
                    JOIN partita p2 ON i.partita_id = p2.id
                    WHERE p2.comune_nome = p_comune_nome
                    GROUP BY i.classificazione
                ) imm_class
            ) AS immobili_per_classe,
            CASE 
                WHEN COUNT(DISTINCT p.id) = 0 THEN 0
                ELSE COUNT(DISTINCT pos.id)::NUMERIC / COUNT(DISTINCT p.id)
            END AS possessori_per_partita
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    SELECT 
        s.comune_nome,
        s.totale_partite,
        s.totale_possessori,
        s.totale_immobili,
        s.partite_attive,
        s.partite_inattive,
        s.immobili_per_classe,
        s.possessori_per_partita
    FROM stats s
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-28 16:14:48,813 - CatastoDB - INFO - Disconnessione completata
